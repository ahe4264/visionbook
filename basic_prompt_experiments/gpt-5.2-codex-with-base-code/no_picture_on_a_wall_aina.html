<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Pinhole Camera Visualization</title>
    <style>
        html,
        body,
        #container {
            margin: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #fdfcf7;
            font-family: "Segoe UI", sans-serif;
        }

        #caption {
            position: absolute;
            top: 1.2rem;
            width: 100%;
            text-align: center;
            color: #3b3b3b;
            letter-spacing: 0.05em;
            font-size: 0.95rem;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="caption">(a) Wide aperture blur &nbsp; | &nbsp; (b) Pinhole projection</div>
    <div id="container"></div>
    <script type="module">
        import * as THREE from 'https://esm.sh/three';
        import { OrbitControls } from 'https://esm.sh/three/examples/jsm/controls/OrbitControls';

        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfdfcf7);

        // Camera
        const aspect = container.clientWidth / container.clientHeight;
        const d = 5.5;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 40);
        camera.position.set(7, 5.5, 7);
        camera.lookAt(0, 1.2, 0);
        camera.zoom = 1.2;
        camera.updateProjectionMatrix();

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Lights
        scene.add(new THREE.HemisphereLight(0xffffff, 0xbec5d4, 0.85));
        const sun = new THREE.DirectionalLight(0xffffff, 0.9);
        sun.position.set(6, 8, 4);
        sun.castShadow = true;
        sun.shadow.mapSize.set(2048, 2048);
        scene.add(sun);

        // Ground
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(14, 8),
            new THREE.MeshStandardMaterial({ color: 0xe9e5d7 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Helpers ---------------------------------------------------------
        function createTree({ trunk = 0x8b4b27, leaves = [0x53c233, 0x6fe03f, 0x8bfd55] } = {}) {
            const group = new THREE.Group();
            const trunkMesh = new THREE.Mesh(
                new THREE.CylinderGeometry(0.11, 0.15, 1.7, 16),
                new THREE.MeshStandardMaterial({ color: trunk, roughness: 0.8 })
            );
            trunkMesh.position.y = 0.85;
            trunkMesh.castShadow = true;
            group.add(trunkMesh);

            const leafCenters = [
                { pos: new THREE.Vector3(0, 1.65, 0), scale: 1.05 },
                { pos: new THREE.Vector3(-0.2, 1.4, 0.25), scale: 0.85 },
                { pos: new THREE.Vector3(0.25, 1.35, -0.2), scale: 0.9 },
                { pos: new THREE.Vector3(0.1, 1.55, 0.35), scale: 0.7 }
            ];

            leafCenters.forEach((cfg, idx) => {
                const leaf = new THREE.Mesh(
                    new THREE.SphereGeometry(0.55 * cfg.scale, 32, 32),
                    new THREE.MeshStandardMaterial({
                        color: leaves[idx % leaves.length],
                        roughness: 0.4,
                        metalness: 0.05
                    })
                );
                leaf.position.copy(cfg.pos);
                leaf.castShadow = true;
                group.add(leaf);
            });
            return group;
        }

        function createWall(width, height, color = 0xf9f8f0) {
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height),
                new THREE.MeshStandardMaterial({ color, side: THREE.DoubleSide, roughness: 0.9 })
            );
            mesh.receiveShadow = true;
            return mesh;
        }

        function createPanelWithHole(width, height, thickness, radius) {
            const shape = new THREE.Shape();
            shape.moveTo(-width / 2, -height / 2);
            shape.lineTo(width / 2, -height / 2);
            shape.lineTo(width / 2, height / 2);
            shape.lineTo(-width / 2, height / 2);
            shape.closePath();

            const hole = new THREE.Path();
            hole.absellipse(0, 0, radius, radius, 0, Math.PI * 2, false);
            shape.holes.push(hole);

            const geometry = new THREE.ExtrudeGeometry(shape, { depth: thickness, bevelEnabled: false });
            const mesh = new THREE.Mesh(
                geometry,
                new THREE.MeshStandardMaterial({ color: 0x121212, metalness: 0.4, roughness: 0.5 })
            );
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createRayPath(points, color, opacity = 1) {
            const geometry = new THREE.BufferGeometry().setFromPoints(points.map(p => p.clone()));
            const material = new THREE.LineBasicMaterial({ color, transparent: opacity < 1, opacity });
            return new THREE.Line(geometry, material);
        }

        function addLabel(text, position) {
            const size = 300;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, size, size);
            ctx.fillStyle = '#1f1f1f';
            ctx.font = 'bold 140px "Segoe UI"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size / 2, size / 2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            const sprite = new THREE.Sprite(
                new THREE.SpriteMaterial({ map: texture, transparent: true })
            );
            sprite.scale.set(1.8, 0.7, 1);
            sprite.position.copy(position);
            scene.add(sprite);
        }

        // Scene (a) -------------------------------------------------------
        const leftWall = createWall(3.2, 2.6);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.position.set(-3.2, 1.3, 0);
        scene.add(leftWall);

        const leftTree = createTree();
        leftTree.position.set(-1.2, 0, 0);
        scene.add(leftTree);

        // Blur blobs on wide wall
        const blurMaterial = new THREE.MeshBasicMaterial({ color: 0xb3f589, transparent: true, opacity: 0.5 });
        [
            { y: 1.2, z: -0.4, scale: 0.9 },
            { y: 1.0, z: 0.1, scale: 0.7 },
            { y: 1.7, z: 0.3, scale: 1.1 }
        ].forEach(cfg => {
            const blur = new THREE.Mesh(new THREE.CircleGeometry(0.7 * cfg.scale, 48), blurMaterial.clone());
            blur.rotation.y = Math.PI / 2;
            blur.position.set(-3.18, cfg.y, cfg.z);
            scene.add(blur);
        });

        // Rays spreading on wide wall
        const leftRayPairs = [
            [new THREE.Vector3(-1.1, 1.55, 0.35), new THREE.Vector3(-3.2, 1.7, 0.5)],
            [new THREE.Vector3(-1.2, 1.2, 0), new THREE.Vector3(-3.2, 1.2, -0.4)],
            [new THREE.Vector3(-1.0, 0.65, -0.2), new THREE.Vector3(-3.2, 0.9, 0.2)],
            [new THREE.Vector3(-1.15, 1.45, -0.25), new THREE.Vector3(-3.2, 1.0, -0.6)]
        ];
        leftRayPairs.forEach(pair => {
            const ray = createRayPath(pair, 0x614016, 0.9);
            scene.add(ray);
        });

        addLabel('Wall', new THREE.Vector3(-3.4, 2.4, 0));

        // Scene (b) -------------------------------------------------------
        const treeRight = createTree({ trunk: 0x794021, leaves: [0x4cb729, 0x65cf34, 0x84f14b] });
        treeRight.position.set(2.6, 0, 0);
        scene.add(treeRight);

        const projectionWall = createWall(2.6, 2.4, 0xf5efe0);
        projectionWall.rotation.y = Math.PI / 2;
        projectionWall.position.set(0, 1.25, 0);
        scene.add(projectionWall);

        const pinholePanel = createPanelWithHole(2.6, 2.8, 0.08, 0.13);
        pinholePanel.rotation.y = Math.PI / 2;
        pinholePanel.position.set(1.1, 1.4, 0);
        scene.add(pinholePanel);

        const holeGlow = new THREE.PointLight(0x9df58c, 0.8, 4);
        holeGlow.position.set(1.1, 1.4, 0);
        scene.add(holeGlow);

        const holeRing = new THREE.Mesh(
            new THREE.RingGeometry(0.14, 0.18, 48),
            new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
        );
        holeRing.rotation.y = Math.PI / 2;
        holeRing.position.set(1.11, 1.4, 0);
        scene.add(holeRing);

        // Projected inverted tree (soft circles)
        const imageGroup = new THREE.Group();
        const screenLeafMaterial = new THREE.MeshBasicMaterial({ color: 0xafeeb1, transparent: true, opacity: 0.7 });
        [
            { y: 0.7, z: 0.05, scale: 0.65 },
            { y: 1.1, z: -0.2, scale: 0.55 },
            { y: 1.5, z: 0.25, scale: 0.5 }
        ].forEach(cfg => {
            const circle = new THREE.Mesh(new THREE.CircleGeometry(0.6 * cfg.scale, 40), screenLeafMaterial.clone());
            circle.rotation.y = Math.PI / 2;
            circle.position.set(0.02, cfg.y, cfg.z);
            imageGroup.add(circle);
        });
        const vase = new THREE.Mesh(
            new THREE.LatheGeometry(
                [
                    new THREE.Vector2(0, 0.2),
                    new THREE.Vector2(0.05, 0.25),
                    new THREE.Vector2(0.15, 0.55),
                    new THREE.Vector2(0.08, 1.1),
                    new THREE.Vector2(0.2, 1.2),
                    new THREE.Vector2(0.08, 1.4)
                ],
                48
            ),
            new THREE.MeshBasicMaterial({ color: 0xd9c2a0, transparent: true, opacity: 0.8 })
        );
        vase.rotation.y = Math.PI / 2;
        vase.position.set(0.01, 0.7, -0.3);
        imageGroup.add(vase);
        scene.add(imageGroup);

        addLabel('Pinhole', new THREE.Vector3(1.1, 2.6, 0));
        addLabel('Projection Wall', new THREE.Vector3(0.1, 2.4, 0));

        // Rays through the pinhole
        const holePoint = new THREE.Vector3(1.1, 1.4, 0);
        const pinholeRays = [
            {
                source: new THREE.Vector3(2.5, 1.7, 0.35),
                screen: new THREE.Vector3(0.05, 0.65, -0.2)
            },
            {
                source: new THREE.Vector3(2.7, 1.3, -0.25),
                screen: new THREE.Vector3(0.05, 1.3, 0.25)
            },
            {
                source: new THREE.Vector3(2.55, 0.8, 0.15),
                screen: new THREE.Vector3(0.05, 1.8, -0.15)
            }
        ];

        pinholeRays.forEach(({ source, screen }) => {
            const ray = createRayPath([source, holePoint, screen], 0x3d8f1c, 0.95);
            scene.add(ray);
        });

        // Brown light rays on projection wall (inside camera)
        const insideRays = [
            {
                source: new THREE.Vector3(2.55, 1.6, -0.1),
                screen: new THREE.Vector3(0.04, 0.75, 0.45)
            },
            {
                source: new THREE.Vector3(2.55, 0.9, -0.35),
                screen: new THREE.Vector3(0.04, 1.75, 0.3)
            }
        ];
        insideRays.forEach(({ source, screen }) => {
            const ray = createRayPath([source, holePoint, screen], 0x744428, 0.9);
            scene.add(ray);
        });

        addLabel('Tree', new THREE.Vector3(2.8, 2.4, 0.6));

        // Controls -------------------------------------------------------
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 1.2, 0);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            const w = container.clientWidth;
            const h = container.clientHeight;
            const newAspect = w / h;
            camera.left = -d * newAspect;
            camera.right = d * newAspect;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        });
    </script>
</body>

</html>