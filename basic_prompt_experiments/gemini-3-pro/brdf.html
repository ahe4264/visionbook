<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Light Scattering Diagram</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffffff;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            font-size: 16px;
            color: #333;
        }

        .label {
            color: #000;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 1px 1px 0 #fff;
            pointer-events: none;
        }
    </style>
    <!-- Import maps polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">Light Scattering Model<br />Drag to rotate | Use controls to change light angle</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        let camera, scene, renderer, labelRenderer;
        let controls;
        let incidentArrow, reflectionArrow;
        let scatterArrows = [];
        let labels = {};

        const params = {
            incidentAngle: 45,
            rotationAngle: 0
        };

        init();
        animate();

        function init() {
            // 1. Scene & Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(5, 4, 5);

            // 2. Renderers
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            document.body.appendChild(labelRenderer.domElement);

            // 3. Controls
            controls = new OrbitControls(camera, labelRenderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 4. Lighting (for the plane appearance)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // 5. Plane (The Green Surface)
            const planeGeometry = new THREE.PlaneGeometry(6, 6);
            const planeMaterial = new THREE.MeshPhongMaterial({
                color: 0x76ff03, // Bright green like the image
                side: THREE.DoubleSide,
                shininess: 10
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);

            // Outline for the plane
            const edges = new THREE.EdgesGeometry(planeGeometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
            line.rotation.x = -Math.PI / 2;
            scene.add(line);

            // 6. Coordinate Frame & Vectors
            const origin = new THREE.Vector3(0, 0, 0);

            // Normal n (Black)
            const normalDir = new THREE.Vector3(0, 1, 0);
            const normalArrow = new THREE.ArrowHelper(normalDir, origin, 1.5, 0x000000, 0.2, 0.1);
            scene.add(normalArrow);
            addLabel(new THREE.Vector3(0, 1.6, 0), "n");

            // Tangent p (Black)
            const pDir = new THREE.Vector3(1, 0, 0);
            const pArrow = new THREE.ArrowHelper(pDir, origin, 1.2, 0x000000, 0.2, 0.1);
            scene.add(pArrow);
            addLabel(new THREE.Vector3(1.3, 0, 0), "p");

            // Tangent q (Black)
            const qDir = new THREE.Vector3(0, 0, 1);
            const qArrow = new THREE.ArrowHelper(qDir, origin, 1.2, 0x000000, 0.2, 0.1);
            scene.add(qArrow);
            addLabel(new THREE.Vector3(0, 0, 1.3), "q");

            // Incident Light l_in (Orange)
            // Function to update light positions is below, we just init here
            incidentArrow = new THREE.ArrowHelper(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 2, 0), 2, 0xffaa00, 0.3, 0.2);
            // Note: ArrowHelper(dir, origin, length, color, headLength, headWidth)
            // But we want the arrow head at the origin for incoming light.
            // So we'll position the arrow at the source and point it down? 
            // Or use an inverted direction? Visual convention: Arrow points TO surface.
            scene.add(incidentArrow);
            labels['lin'] = addLabel(new THREE.Vector3(), "ℓ_in(λ)");

            // Outgoing Light l_out (Dark Green) - Specular/Main reflection
            reflectionArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), origin, 2, 0x006400, 0.3, 0.2);
            scene.add(reflectionArrow);
            labels['lout'] = addLabel(new THREE.Vector3(), "ℓ_out = F(...)");

            // Scattered rays (Lighter Green, semi-transparent)
            for (let i = 0; i < 8; i++) {
                const arr = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), origin, 1 + Math.random() * 0.5, 0x33ff33, 0.2, 0.1);
                scene.add(arr);
                scatterArrows.push(arr);
            }

            // 7. GUI
            const gui = new GUI();
            gui.add(params, 'incidentAngle', 0, 85).name('Incident Angle').onChange(updateVectors);
            gui.add(params, 'rotationAngle', 0, 360).name('Rotation').onChange(updateVectors);

            updateVectors();
        }

        function addLabel(position, text) {
            const div = document.createElement('div');
            div.className = 'label';
            div.textContent = text;
            // Handle subscripts roughly
            div.innerHTML = text.replace(/_([a-z]+)/g, "<sub>$1</sub>");

            const label = new CSS2DObject(div);
            label.position.copy(position);
            scene.add(label);
            return label;
        }

        function updateVectors() {
            const radInc = THREE.MathUtils.degToRad(params.incidentAngle);
            const radRot = THREE.MathUtils.degToRad(params.rotationAngle);

            // Calculate Incident Vector Direction (pointing TO origin)
            // Source position in spherical coords
            const y = Math.cos(radInc);
            const h = Math.sin(radInc); // horizontal projection length
            const x = h * Math.sin(radRot);
            const z = h * Math.cos(radRot);

            const sourcePos = new THREE.Vector3(x, y, z).multiplyScalar(2.0);
            const incDir = sourcePos.clone().normalize().negate(); // Points from source to origin

            // Update Incident Arrow
            // We want the arrow head at (0,0,0). ArrowHelper draws FROM origin.
            // So we place origin at sourcePos and direction = incDir.
            incidentArrow.position.copy(sourcePos);
            incidentArrow.setDirection(incDir);
            incidentArrow.setLength(sourcePos.length(), 0.3, 0.2);

            // Update Label Position
            labels['lin'].position.copy(sourcePos.clone().multiplyScalar(0.5));

            // Calculate Perfect Reflection (Specular)
            const normal = new THREE.Vector3(0, 1, 0);
            const reflectDir = incDir.clone().reflect(normal).normalize(); // reflect() in Three.js usually reflects off the plane normal, result depends on convention.
            // Three.js Vector3.reflect(normal) formula: v - 2 * dot(v, n) * n.
            // If v is incoming (down), dot is negative.
            // Let's manually compute reflection: R = I - 2(I.N)N ?? No, usually R = I - 2(I.N)N is for I pointing TO surface.
            // Note: Three.js reflect modifies the vector in place. 
            // incDir points DOWN. Normal UP.
            // reflectDir should point UP.

            // Let's re-calculate perfectly:
            // L = -incDir (points to light)
            // R = 2(N.L)N - L
            const viewDir = incDir.clone().negate(); // Points to light
            const dot = normal.dot(viewDir);
            const rVec = normal.clone().multiplyScalar(2 * dot).sub(viewDir).normalize();

            reflectionArrow.setDirection(rVec);
            reflectionArrow.setLength(2.0, 0.3, 0.2);
            labels['lout'].position.copy(rVec.clone().multiplyScalar(2.2)); // Tip of arrow

            // Update Scatter Arrows (Random perturbations around reflection or normal for diffuse)
            scatterArrows.forEach((arrow, i) => {
                // Mix between normal and reflection for a lobe
                const mix = 0.5;
                // Simple hemispherical scatter or centered around reflection
                // Let's do a lobe around the reflection vector
                const jitter = new THREE.Vector3(
                    (Math.random() - 0.5),
                    (Math.random() - 0.5),
                    (Math.random() - 0.5)
                ).multiplyScalar(0.8);

                const scatterDir = rVec.clone().add(jitter).normalize();
                // Ensure it points up
                if (scatterDir.y < 0) scatterDir.y = -scatterDir.y;

                arrow.setDirection(scatterDir);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>